<pre class="metadata">
Title: Subresource Integrity
Status: CR
Deadline: 2015-12-15
ED: https://w3c.github.io/webappsec-subresource-integrity/
TR: http://www.w3.org/TR/SRI/
Previous Version: http://www.w3.org/TR/2015/WD-SRI-20151006/
Shortname: SRI
Level: 1
Editor: Devdatta Akhawe, Dropbox Inc., dev.akhawe@gmail.com
Editor: Frederik Braun 68466, Mozilla, fbraun@mozilla.com
Editor: Francois Marier, Mozilla, francois@mozilla.com
Editor: Joel Weinberger, Google Inc., jww@google.com
Abstract:
  This specification defines a mechanism by which user agents may verify that a
  fetched resource has been delivered without unexpected manipulation.
Group: webappsec
Indent: 2
Version History: https://github.com/w3c/webappsec-subresource-integrity/commits/gh-pages
!Participate: <a href="https://github.com/w3c/webappsec-subresource-integrity/issues/new">File a bug </a> (<a href="https://github.com/w3c/webappsec-subresource-integrity/issues">open issues</a>)
Markup Shorthands: css off, markdown on
</pre>

<!-- TODO:
       * Add metadata for implementionReportURI
       * Find way to add editor Websites and Company URLs.
-->

<pre class="anchors">
spec: ABNF; urlPrefix: https://tools.ietf.org/html/rfc5234
  type: dfn
    text: VCHAR; url: appendix-B.1

spec: CSP2; urlPrefix: http://www.w3.org/TR/CSP2
  type: dfn
    text: hash-source; url: source-list-syntax

spec: Fetch; urlPrefix: https://fetch.spec.whatwg.org
  type: dfn
    text: request; url: concept-request-integrity-metadata

spec: HTML5; urlPrefix: http://www.w3.org/TR/html5/
  type: dfn
    urlPrefix: infrastructure.html
      text: White_Space characters; url: #space-character

spec: RFC1321; urlPrefix: https://www.ietf.org/rfc/rfc1321.txt
  type: dfn
    text: MD5; url: #

spec: RFC6797; urlPrefix: https://tools.ietf.org/html/rfc6797
  type: dfn
    text: Strict-Transport-Security; url: section-6.1

spec: RFC7469; urlPrefix: https://tools.ietf.org/html/rfc7469
  type: dfn
    text: Public Key Pinning; url: section-1

spec: SHA2; urlPrefix: http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
  type: dfn
    text: SHA-1; url: #
    text: SHA-2; url: #
    text: SHA-256; url: #
    text: SHA-384; url: #
    text: SHA-512; url: #
</pre>

<pre class="biblio">
{
  "SECURE-CONTEXTS": {
    "authors": [ "Mike West", "Yan Zhu" ],
    "href": "http://www.w3.org/TR/powerful-features/",
    "title": "Privileged Contexts",
    "status": "WD",
    "publisher": "W3C"
  },
  "SHA2": {
    "href": "http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf",
    "title": "FIPS PUB 180-4, Secure Hash Standard"
  }
}
</pre>

<!-- ####################################################################### -->

# Introduction # {#intro}

<em> This section is not normative.</em>

Sites and applications on the web are rarely composed of resources from only a
single origin. For example, authors pull scripts and styles from a wide variety
of services and content delivery networks, and must trust that the delivered
representation is, in fact, what they expected to load. If an attacker can trick
a user into downloading content from a hostile server (via DNS [[RFC1035]]
poisoning, or other such means), the author has no recourse. Likewise, an
attacker who can replace the file on the Content Delivery Network (CDN) server
has the ability to inject arbitrary content.

Delivering resources over a secure channel mitigates some of this risk: with TLS
[[TLS]], <a lt="Strict-Transport-Security">HTTP Strict Transport Security (HSTS)
</a> [[RFC6797]], and <a>Public Key Pinning</a> [[RFC7469]], a user agent can be
fairly certain that it is indeed speaking with the server it believes it's
talking to. These mechanisms, however, authenticate <em>only</em> the server,
<em>not</em> the content. An attacker (or administrator) with access to the
server can manipulate content with impunity.  Ideally, authors would not only be
able to pin the keys of a server, but also pin the <em>content</em>, ensuring
that an exact representation of a resource, and <em>only</em> that
representation, loads and executes.

This document specifies such a validation scheme, extending two HTML elements
with an `integrity` attribute that contains a cryptographic hash of
the representation of the resource the author expects to load. For instance, an
author may wish to load some framework from a shared server rather than hosting
it on their own origin. Specifying that the <em>expected</em> SHA-384 hash of
`https://example.com/example-framework.js` is
`Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7`
means that the user agent can verify that the data it loads from that URL
matches that expected hash before executing the JavaScript it contains. This
integrity verification significantly reduces the risk that an attacker can
substitute malicious content.

This example can be communicated to a user agent by adding the hash to a
`script` element, like so:

<div class="example">
  <pre>
    &lt;script src="https://example.com/example-framework.js"
            integrity="sha384-Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7"
            crossorigin="anonymous"&gt;&lt;/script&gt;
  </pre>
</div>

Scripts, of course, are not the only response type which would benefit from
integrity validation. The scheme specified here also applies to
`link` and future versions of this specification are likely to expand
this coverage.


## Goals ## {#goals}

1.  Compromise of a third-party service should not automatically mean
    compromise of every site which includes its scripts. Content authors
    will have a mechanism by which they can specify expectations for
    content they load, meaning for example that they could load a
    <em>specific</em> script, and not <em>any</em> script that happens to have a
    particular URL.

2.  The verification mechanism should have error-reporting functionality which
    would inform the author that an invalid response was received.

## Use Cases/Examples ## {#examples}

### Resource Integrity ### {#resource-integrity}

*   An author wishes to use a content delivery network to improve performance
    for globally-distributed users. It is important, however, to ensure that
    the CDN's servers deliver <em>only</em> the code the author expects them to
    deliver. To mitigate the risk that a CDN compromise (or unexpectedly
    malicious behavior) would change that site in unfortunate ways, the
    following <a>integrity metadata</a> is added to the `link`
    element included on the page:

    <div class="example">
      <pre>
        &lt;link rel="stylesheet" href="https://site53.example.net/style.css"
              integrity="sha384-+/M6kredJcxdsqkczBUjMLvqyHb1K/JThDXWsBVxMEeZHEaMKEOEct339VItX1zB"
              crossorigin="anonymous">
      </pre>
    </div>

*   An author wants to include JavaScript provided by a third-party
    analytics service. To ensure that only the code that has been carefully
    reviewed is executed, the author generates <a>integrity metadata</a> for
    the script, and adds it to the `script` element:

    <div class="example">
      <pre>
        &lt;script src="https://analytics-r-us.example.com/v1.0/include.js"
                integrity="sha384-MBO5IDfYaE6c6Aao94oZrIOiC6CGiSN2n4QUbHNPhzk5Xhm0djZLQqTpL0HzTUxk"
                crossorigin="anonymous">&lt;/script>
      </pre>
    </div>

*   A user agent wishes to ensure that JavaScript code running in high-privilege
    HTML contexts (for example, a browser's New Tab page) aren't manipulated
    before display. <a>Integrity metadata</a> mitigates the risk that altered
    JavaScript will run in these pages' high-privilege contexts.

<!-- ####################################################################### -->

# Key Concepts and Terminology # {#terms}

This section defines several terms used throughout the document.

The term <dfn>digest</dfn> refers to the <a lt="base64 encoding">base64
encoded</a> result of executing a cryptographic hash function on an arbitrary
block of data.

The term <dfn>origin</dfn> is defined in the Origin specification.
[[!RFC6454]]

The <dfn>representation data</dfn> and <dfn>content encoding</dfn> of a resource
are defined by <a href="https://tools.ietf.org/html/rfc7231#section-3">Section 3
of RFC 7231</a>. [[!RFC7231]]

A <dfn>base64 encoding</dfn> is defined in
<a href="https://tools.ietf.org/html/rfc4648#section-4">Section 4 of RFC
4648</a>. [[!RFC4648]]

<a>SHA-256</a>, <a>SHA-384</a>, and <a>SHA-512</a> are part
of the <a>SHA-2</a> set of cryptographic hash functions defined by the
NIST. [[!SHA2]]

## Grammatical Concepts ## {#grammar}
The Augmented Backus-Naur Form (ABNF) notation used in this document is
specified in RFC5234. [[!ABNF]]

<a href="https://tools.ietf.org/html/rfc5234#appendix-B.1">Appendix B.1 of ABNF
</a> defines <a>`VCHAR`</a> (printing characters). [[!ABNF]]

<dfn>`WSP`</dfn>  are defined in the HTML 5 specification as <a>`White_Space
characters`</a>. [[!HTML5]]

<!-- ####################################################################### -->

# Framework # {#framework}

The integrity verification mechanism specified here boils down to the process of
generating a sufficiently strong cryptographic digest for a resource, and
transmitting that digest to a user agent so that it may be used to verify the
response.

## Integrity metadata ## {#metadata}

To verify the integrity of a response, a user agent requires <dfn>integrity
metadata</dfn> as part of the <a>request</a>. This metadata consists of the
following pieces of information:

* cryptographic hash function ("`alg`")
* <a>digest</a> ("`val`")
* options ("`opt`")

The hash function and digest MUST be provided in order to validate a
response's integrity.

<div class="note">
At the moment, no options are defined. However, future versions of
the spec may define options, such as MIME types. [[MIME-TYPES]]
</div>

This metadata MUST be encoded in the same format as the <a>`hash-source`</a>
(without the single quotes) in [[!CSP2]].

For example, given a script resource containing only the string
`\"alert(\'Hello, world.\');\"`, an author might choose <a>SHA-384</a> as a hash
function.  `H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO` is
the <a lt="base64 encoding">base64 encoded</a> <a>digest</a> that results. This
can be encoded as follows:

<div class="example">
  <pre>
    sha384-H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO
  </pre>
</div>

<div class="note">
Digests may be generated using any number of utilities.  <a
href="https://openssl.org/">OpenSSL</a>, for example, is quite commonly
available. The example in this section is the result of the following command
line:

  <pre>
    echo -n "alert('Hello, world.');" | openssl dgst -sha384 -binary | openssl base64 -A
  </pre>
</div>

## Cryptographic hash functions ## {#cryptographic-hash-functions}

Conformant user agents MUST support the <a>SHA-256</a>, <a>SHA-384</a>,
and <a>SHA-512</a> cryptographic hash functions for use as part of a
request's <a>integrity metadata</a> and MAY support additional hash functions.

User agents SHOULD refuse to support known-weak hashing functions like
<a>MD5</a> or <a>SHA-1</a> and SHOULD restrict supported hashing functions to
those known to be collision-resistant. Additionally, user agents SHOULD
re-evaluate their supported hash functions on a regular basis and deprecate
support for those functions that have become insecure. See
[#hash-collision-attacks].

### Agility ### {#agility}

Multiple sets of <a>integrity metadata</a> may be associated with a single
resource in order to provide agility in the face of future cryptographic
discoveries.  For example, the resource described in the previous section may be
described by either of the following hash expressions:

<div class="example">
  <pre>
    sha384-dOTZf16X8p34q2/kYyEFm0jh89uTjikhnzjeLeF0FHsEaYKb1A1cv+Lyv4Hk8vHd
    sha512-Q2bFTOhEALkN8hOms2FKTDLy7eugP2zFZ1T8LCvX42Fp3WoNr3bjZSAHeOsHrbV1Fu9/A0EzCinRE7Af1ofPrw==
  </pre>
</div>

Authors may choose to specify both, for example:

<div class="example">
  <pre>
    &lt;script src="hello_world.js"
       integrity="sha384-dOTZf16X8p34q2/kYyEFm0jh89uTjikhnzjeLeF0FHsEaYKb1A1cv+Lyv4Hk8vHd
                  sha512-Q2bFTOhEALkN8hOms2FKTDLy7eugP2zFZ1T8LCvX42Fp3WoNr3bjZSAHeOsHrbV1Fu9/A0EzCinRE7Af1ofPrw=="
       crossorigin="anonymous">&lt;/script>
  </pre>
</div>

In this case, the user agent will choose the strongest hash function in the
list, and use that metadata to validate the response (as described below in the
<a>parse metadata</a> and <a>get the strongest metadata from set</a>
algorithms).

When a hash function is determined to be insecure, user agents SHOULD deprecate
and eventually remove support for integrity validation using the insecure hash
function. User agents MAY check the validity of responses using a digest based
on a deprecated function.

To allow authors to switch to stronger hash functions without being held back by
older user agents, validation using unsupported hash functions acts like no
integrity value was provided (see the <a>Does response match metadataList</a>
algorithm below).  Authors  are encouraged to use strong hash functions, and to
begin migrating to stronger hash functions as they become available.

### Priority ### {#priority}

User agents must provide a mechanism for determining the relative priority of
two hash functions and return the empty string if the priority is equal. That
is, if a user agent implemented a function like
<dfn>getPrioritizedHashFunction</dfn>(a, b) it would return the hash function
the user agent considers the most collision-resistant.  For example,
`getPrioritizedHashFunction('sha256', 'sha512')` would return `'sha512'` and
`getPrioritizedHashFunction('sha256', 'sha256')` would return the empty string.

<div class="note">
  The <a>getPrioritizedHashFunction</a> is an internal implementation detail.
  It is not an API that implementors provide to web applications. It is used in
  this document only to simplify the algorithm description.
</div>

<dfn>parse metadata</dfn>
<dfn>get the strongest metadata from set</dfn>
<dfn>does response match metadatalist</dfn>
